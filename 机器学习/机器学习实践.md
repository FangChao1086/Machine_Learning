# 机器学习实践

* [数据处理](#数据处理)
  * [性别_转换成数值](#性别_转换成数值)
  * [缺失值填充](#缺失值填充)
    * [年龄_随机森林预测](#年龄_随机森林预测)
  * [数据划分_shuffle](#数据划分_shuffle)
* [模型保存与加载](#模型保存与加载)
* [regression](#regression)
  * [回归](#回归)  
    * [LinearRegression](#LinearRegression)
    * [Lasso/Ridge--GridSearchCV](#Lasso)
  * [分类](#分类)  
    * [LogisticRegression--Pipeline](#LogisticRegression)
* [RandomForest](#RandomForest)
  * [分类](#分类_R)  
    * [RandomForestClassifier](#RandomForestClassifier)
* [GBDT](#GBDT)
  * [回归](#回归_GBDT)
    * [GradientBoostingRegressor](#GradientBoostingRegressor)
    * [GradientBoostingRegressor--GridSearchCV](#GradientBoostingRegressor--GridSearchCV)
  * [分类](#分类_GBDT)
    * [GradientBoostingClassifier](#GradientBoostingClassifier)
* [XGBoost](#XGBoost)
* [GBDT(梯度提升树简易教程)](#GBDT(梯度提升树简易教程))
* [pandas](#pandas)
  * [pandas编码objects type](#pandas编码objects_type)
* [keras](#keras)
  * [网络建模](#网络建模)
  * [模型存储、加载、查看、网络可视化](#模型存储、加载、网络可视化)

<span id="数据处理"></span>
## 数据处理
<span id="性别"></span>
## 性别_转换成数值
```python
data['Sex'] = data['Sex'].map({'female': 0, 'male': 1}).astype(int)
```
<span id="缺失值填充"></span>
## 缺失值填充
<span id="年龄_随机森林预测"></span>
### 年龄_随机森林预测
```python
from sklearn.ensemble import RandomForestRegressor

data_for_age = data[['Age', 'Survived', 'Fare', 'Parch', 'SibSp', 'Pclass']]
age_exist = data_for_age.loc[(data.Age.notnull())]   # 年龄不缺失的数据
age_null = data_for_age.loc[(data.Age.isnull())]
x = age_exist.values[:, 1:]
y = age_exist.values[:, 0]

rfr = RandomForestRegressor(n_estimators=1000)
rfr.fit(x, y)
age_hat = rfr.predict(age_null.values[:, 1:])
data.loc[(data.Age.isnull()), 'Age'] = age_hat
```

<span id="数据划分_shuffle"></span>
## 数据划分_shuffle
```python
import random

# data, label; len:42000
index = [i for i in range(len(data))]
random.shuffle(index)
data = data[index]
label = label[index]
(x_train, x_val) = (data[0:30000], data[30000:])
(y_train, y_val) = (label[0:30000], label[30000:])
```

<span id="模型保存与加载"></span>
## 模型保存与加载
```python
from sklearn.externals import joblib

# 模型保存
# gbr.fit(x_train, y_train)
joblib.dump(gbr, 'train_model.m')   # 保存模型

# 模型加载
gbr = joblib.load('train_model.m')
# prediction_text = gbr.prediction(x_test)
```

<span id="regression"></span>
## regression  
<span id="回归"></span>
[链接：详细代码](https://github.com/FangChao1086/Machine_learning/tree/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Regression)
## 回归
<span id="LinearRegression"></span>
### LinearRegression
```python
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

# 训练
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=1)
lin_reg = LinearRegression()
lin_reg.fit(x_train, y_train)
# 参数
print(lin_reg.coef_)
print(lin_reg.intercept_)

# 预测评估
y_hat = lin_reg.predict(x_test)
mse_loss = mean_squared_error(y_test, y_hat)
print('mse:', mse_loss)
```
<span id="Lasso"></span>
### Lasso/Ridge--GridSearchCV
```python
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.linear_model import Lasso, Ridge
from sklearn.metrics import r2_score

# 训练
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=1)
model = Lasso()     # L1
# model = Ridge()   # L2
alpha_scan = np.logspace(-6, 2, 10)
lasso_model = GridSearchCV(model, param_grid={'alpha': alpha_scan}, cv=5)
lasso_model.fit(x_train, y_train)
# 参数
print(lasso_model.best_params_)

# 预测评估
y_hat = lasso_model.predict(x_test)
r2 = r2_score(y_test, y_hat)
print("r2_score:", r2)
```
<span id="分类"></span>
## 分类
<span id="LogisticRegression"></span>
### LogisticRegression--Pipeline
```python
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.metrics import roc_curve

# 训练
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=1, stratify=y)
model = Pipeline([('sc', StandardScaler()),
                  ('clf', LogisticRegression())])
model.fit(x_train, y_train)
# 参数
print(model.get_params())

# 预测评估
y_hat = model.predict(x_test)
fpr, tpr, threshold = roc_curve(y_test, y_hat)
  ## 画图
## 中文显示
# import matplotlib as mpl
# mpl.rcParams['font.sans-serif'] = [u'simHei']
# mpl.rcParams['axes.unicode_minus'] = False
```

<span id="RandomForest"></span>
## RandomForest  
[链接：详细代码](https://github.com/FangChao1086/Machine_learning/tree/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/RandomForest)  
<span id="分类_R"><span>
## 分类
<span id="RandomForestClassifier"></span>  
### RandomForestClassifier  
```python
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score

# 训练
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1, stratify=y)
clf = RandomForestClassifier(n_estimators=500, max_depth=6,
                             min_samples_leaf=3, criterion="gini",
                             random_state=1, n_jobs=-1)
clf.fit(X_train, y_train)

# 预测评估
prediction = clf.predict(X_test)
acc = accuracy_score(y_test, prediction)
print('The accuracy of Random Forest is {}'.format(acc))
```

<span id="GBDT"></span>
## GBDT
[链接：详细代码](https://github.com/FangChao1086/Machine_learning/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/GBDT/READ.md)  
<span id="回归_GBDT"></span>
## 回归
<span id="GradientBoostingRegressor"></span>
### GradientBoostingRegressor
```python
from sklearn.datasets import load_boston
from sklearn.model_selection import train_test_split
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.metrics import mean_squared_error

# 训练
x_train, x_test, y_train, y_test = train_test_split(load_boston().data, load_boston().target,
                                                    test_size=0.2, random_state=1)
reg_model = GradientBoostingRegressor(
    loss='ls',
    learning_rate=0.01,
    n_estimators=180,
    subsample=0.8,
    max_features=0.8,
    max_depth=4,
    verbose=2
)
reg_model.fit(x_train, y_train)

# 预测与评估
prediction_train = reg_model.predict(x_train)
mse_train = mean_squared_error(y_train, prediction_train)
prediction_test = reg_model.predict(x_test)
mse_test = mean_squared_error(y_test, prediction_test)
print("mse_train:%f  mse_test:%f " % (mse_train, mse_test))
```
<span id="GradientBoostingRegressor--GridSearchCV"></span>
## GradientBoostingRegressor--GridSearchCV
```python
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import mean_squared_error

# 未使用GridSearchCV
# 训练
x_train, x_test, y_train, y_test = train_test_split(X, y, random_state=2)
clf = GradientBoostingRegressor(loss='quantile')
clf.fit(x_train, y_train)
# 预测评估
prediction_test = clf.predict(x_test)
mse_test = mean_squared_error(prediction_test, y_test)
print('原始_mse_test = %f' % mse_test)


# GridSearchCV
# 对boosting框架参数：对损失函数'quantile'的分位数α和权重缩放率learning_rate进行调参
param_test1 = {'alpha': np.linspace(0.3, 0.9, 7),
               'learning_rate': np.linspace(0.2, 0.9, 8)}
gr_model = GridSearchCV(
    estimator=GradientBoostingRegressor(
        n_estimators=100,
        loss='quantile', random_state=10
    ),
    param_grid=param_test1,
    iid=False,
    cv=5
)
gr_model.fit(x_train, y_train)
print('得到最佳参数：%s    最佳得分：%f' % (gr_model.best_params_, gr_model.best_score_))

# 训练，使用最佳参数
clf = GradientBoostingRegressor(loss='quantile', alpha=0.5, learning_rate=0.2)
clf.fit(x_train, y_train)

# 预测评估（GridSearchCV）
prediction_test = clf.predict(x_test)
mse_test = mean_squared_error(prediction_test, y_test)
print('GridSearchCV_mse_test = %f' % mse_test)
```

<span id="分类_GBDT"></span>
## 分类
<span id="GradientBoostingClassifier"></span>
### GradientBoostingClassifier
```python
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import confusion_matrix

# 训练
x_train, x_test, y_train, y_test = train_test_split(load_iris().data, load_iris().target,
                                                    test_size=0.2, random_state=1, stratify=load_iris().target)
cl_model = GradientBoostingClassifier(
    loss='deviance',
    learning_rate=0.001,
    n_estimators=50,
    subsample=0.8,
    max_features=0.8,
    max_depth=3,
    verbose=2
)
cl_model.fit(x_train, y_train)

# 预测与评估（混淆矩阵）
prediction_train = cl_model.predict(x_train)
cm_train = confusion_matrix(y_train, prediction_train)
prediction_test = cl_model.predict(x_test)
cm_test = confusion_matrix(y_test, prediction_test)
print("Confusion_matrix\n train:\n%s\ntest:\n%s" % (cm_train, cm_test))
```

<span id="XGBoost"></span>  
## XGBoost
[链接：详细代码](https://github.com/FangChao1086/Machine_learning/tree/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/XGBOOST)
```python
import xgboost as xgb

# 训练测试集读取
x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=1, test_size=0.5)
data_train = xgb.DMatrix(x_train, label=y_train)
data_test = xgb.DMatrix(x_test, label=y_test)

# 训练
watch_list = [(data_test, 'eval'), (data_train, 'train')]
param = {'max_depth': 3, 'eta': 1, 'silent': 0, 'objective': 'multi:softmax', 'num_class': 3}
bst = xgb.train(param, data_train, num_boost_round=4, evals=watch_list)

# 预测
y_hat = bst.predict(data_test)
```

<span id="GBDT(梯度提升树简易教程)"></span>
## GBDT(梯度提升树简易教程)
[参考链接：GBDT(梯度提升树简易教程)](https://github.com/Freemanzxp/GBDT_Simple_Tutorial)  

 回归  
 二分类  
 多分类  
 可视化  
 
### 结果：
![GBDT-regression](https://i.ibb.co/3SLfzR7/GBDT-regression.png)  

<span id="pandas"></span>
## pandas
<span id="pandas编码objects_type"></span>
### pandas编码objects type
```python
# 编码所有的object type
from sklearn import preprocessing

for x in train.columns:
    if train[x].dtype == 'object':
        lbl = preprocessing.LabelEncoder()
        lbl.fit(list(train[x].values))
        train[x] = lbl.transform(list(train[x].values))

```

<span id="keras"></span>
## keras
[链接：keras_手写数字识别](https://github.com/FangChao1086/Machine_learning/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B.md#keras_%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB)  
<span id="网络建模"></span>
## 网络建模
```python
from keras.models import Sequential
from keras.layers import MaxPooling2D, Conv2D
from keras.layers.core import Flatten, Dense, Activation

def create_model():
    model = Sequential()

    model.add(Conv2D(filters=4, kernel_size=(5, 5), strides=(1, 1),
                     padding='valid', activation='relu', input_shape=(1, 28, 28)))  # (None, 4, 24, 24)

    model.add(Conv2D(filters=8, kernel_size=(3, 3), strides=(1, 1),
                     activation='relu', padding='valid'))  # (None, 8, 22, 22)
    model.add(MaxPooling2D(pool_size=(2, 2)))  # (None, 8, 11, 11)

    model.add(Conv2D(filters=16, kernel_size=(3, 3), strides=(1, 1),
                     activation='relu', padding='valid'))  # (None, 16, 9, 9)
    model.add(MaxPooling2D(pool_size=(2, 2)))  # (None, 16, 4, 4)

    model.add(Flatten())  # (None, 256)
    model.add(Dense(units=128))  # (None, 128)
    model.add(Activation('relu'))

    model.add(Dense(units=nb_class, activation='softmax'))  # (None, nb_class)

    return model
```

<span id="模型存储、加载、网络可视化"></span>
## 模型存储、加载、查看、网络可视化
```python
import keras
from keras.utils.vis_utils import plot_model

# 模型存储、加载、网络可视化
model.save('model.h5')
origin_model = keras.models.load_model('model.h5')  # 模型加载
print(origin_model.summary())  # 查看模型
plot_model(origin_model, to_file='model.png')  # 神经网络可视化
```
